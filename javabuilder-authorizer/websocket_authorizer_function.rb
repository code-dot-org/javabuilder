require 'aws-sdk-lambda'
require 'aws-sdk-dynamodb'
require 'aws-sdk-cloudwatch'
require 'jwt'
require_relative 'jwt_helper'
require_relative 'token_status'
include JwtHelper
include TokenStatus

# The lambda handler takes an event with the query string parameter 'Authorization=token',
# where the token is a JWT token generated by dashboard or a string indicating this is
# a basic connection test from a user. It checks the validity of the token and returns
# a policy that either allows or disallows the user from continuing to Javabuilder. This
# authorizer is specialized to work with AWS API Gateway WebSocket APIs.
def lambda_handler(event:, context:)
  origin = event['headers']['Origin']
  jwt_token = event['queryStringParameters']['Authorization']
  method_arn = event['methodArn']
  # Return early if this is the user connectivity test
  if jwt_token == 'connectivityTest'
    return JwtHelper.generate_policy('connectivityTest', "Allow", method_arn, {connectivityTest: true})
  end

  standardized_origin = JwtHelper.get_standardized_origin(origin)
  decoded_token = JwtHelper.decode_token(jwt_token, standardized_origin)
  return JwtHelper.generate_deny(method_arn) unless decoded_token

  token_payload = decoded_token[0]
  token_info = get_token_info(context, token_payload['sid'])
  token_status = token_info[:status]
  return JwtHelper.generate_allow_with_error(method_arn, token_status) if TokenStatus::ERROR_STATES.include?(token_status)
  return JwtHelper.generate_allow_with_warning(method_arn, token_payload, token_status, token_info[:detail]) if TokenStatus::WARNING_STATES.include?(token_status)

  JwtHelper.generate_allow(method_arn, token_payload)
end

def get_token_info(context, sid)
  region = get_region(context)
  function_name = context.function_name
  dynamodb_client = Aws::DynamoDB::Client.new(region: region)
  cloudwatch_client = Aws::CloudWatch::Client.new(region: region)
  response = dynamodb_client.get_item(
    table_name: ENV['token_status_table'],
    key: {token_id: sid}
  )
  item = response.item

  return error(cloudwatch_client, TokenStatus::UNKNOWN_ID, function_name, sid) unless item
  return error(cloudwatch_client, TokenStatus::TOKEN_USED, function_name, sid) if item['used']
  return error(cloudwatch_client, TokenStatus::NOT_VETTED, function_name, sid) unless item['vetted']

  dynamodb_client.update_item(
    table_name: ENV['token_status_table'],
    key: {token_id: sid},
    update_expression: 'SET used = :u',
    expression_attribute_values: {':u': true}
  )

  if item['warning']
    warning = item['warning']
    # remaining is the number of requests remaining before throttling. Dynamodb
    # returns this in scientific format (ex. 0.1e2 for 10). Convert this decimal format.
    if warning['detail']['remaining']
      warning['detail']['remaining'] = warning['detail']['remaining'].to_i
    end
    puts "TOKEN VALIDATION WARNING: #{warning['key']} detail: #{warning['detail']} token_id: #{sid}"
    return {status: warning['key'], detail: warning['detail']}
  end

  return {status: TokenStatus::VALID_WEBSOCKET}
end

# ARN is of the format arn:aws:lambda:{region}:{account_id}:function:{lambda_name}
def get_region(context)
  context.invoked_function_arn.split(':')[3]
end

def error(client, status, function_name, sid)
  puts "TOKEN VALIDATION ERROR: #{status} token_id: #{sid}"
  metric_data = {
    metric_name: status,
    dimensions: [
      {
        name: "functionName",
        value: function_name
      }
    ],
    unit: "Count",
    value: 1
  }

  client.put_metric_data({namespace: "Javabuilder", metric_data: [metric_data]})

  {status: status}
end
